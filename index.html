<!DOCTYPE html>
<html>
<head>
    <title>TEST</title>
    <script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
    <style type="text/css">
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        canvas {
            height: 100vh;
            width: 100vw;
            display: block;
        }
    </style>
</head>
<body onload="webGLStart();">
    <canvas id="canvas"></canvas>
</body>
<script type="text/javascript" src="index.js"></script>

<script id="vertex-shader" type="x-shader/x-vertex">
    attribute vec2 aTextureCoord;
    attribute vec2 aVertexPosition;

    uniform bool uIsBuffer;
    uniform float uBGAspect;
    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;

    varying vec2 vTextureCoord;

    void main() {
        vec4 XY;

        if (uIsBuffer) {
            // Appy corrct aspect
            XY = vec4(aVertexPosition * vec2(1, uBGAspect), 0, 1);
        } else {
            // Appy Model-View-Model matrix transformation
            XY = uPMatrix * uMVMatrix * vec4(aVertexPosition, 0, 1);
        }

        gl_Position = XY;
        vTextureCoord = aTextureCoord;
    }
</script>

<script id="fragment-shader" type="x-shader/x-fragment">
    precision mediump float;

    uniform bool uIsBuffer;
    uniform sampler2D uSampler;
    uniform vec2 uInitialTextureOffset;
    uniform vec2 uTextureOffset;

    varying vec2 vTextureCoord;

    void main() {
        vec2 XY;

        if (uIsBuffer) {
            // Add initial and current offset
            XY = vTextureCoord + uInitialTextureOffset + uTextureOffset;
        } else {
            vec2 multiplier = vec2(.08, 0);
            vec2 recover = vec2(1.09, 1);
            vec2 originOffset = vec2(0, -1);

            XY = vTextureCoord;
            float R;
            bvec2 isValid;

            // Normalize components from range {0, 1} to {-1, 1}
            XY = (2. * XY) - 1.;

            // Apply origin offset
            XY += originOffset;
            R = dot(XY, XY);
            XY -= originOffset;

            // Calculate distortion
            XY *= (1. - multiplier * R);

            // Recover edges
            XY *=  recover;

            // Filter valid regions
            isValid = lessThanEqual(abs(XY), vec2(1, 1));
            if (isValid.x && isValid.y) {
                // De-normalize
                XY = (XY + 1.) / 2.;
            } else {
                discard;
            }
        }

        gl_FragColor = texture2D(uSampler, XY);
    }
</script>
</html>
